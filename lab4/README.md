# Лабораторная работа 4: Обработка событий в pygame

## Описание работы

В данной лабораторной работе мы изучили основы работы с библиотекой pygame, включая обработку событий, создание спрайтов и групп спрайтов в парадигме объектно-ориентированного программирования, а также реализацию коллизий объектов.

## Анализ существующего кода

### Основные классы и их функциональность

1. **BaseSprite** - базовый класс для всех игровых объектов:
   - Управляет базовыми свойствами спрайта (изображение, позиция, скорость)
   - Обрабатывает движение и проверку выхода за границы области
   - Отслеживает изменения позиции для других объектов

2. **Character** - класс для игровых персонажей:
   - Наследуется от BaseSprite
   - Реализует гравитацию и физику движения
   - Обрабатывает столкновения с платформами
   - Управляет анимацией персонажа

3. **Actor** - класс для активных персонажей:
   - Наследуется от Character
   - Реализует базовые действия: движение, прыжок, стрельба
   - Управляет направлением движения

4. **Hero** - класс главного персонажа:
   - Наследуется от Actor
   - Обрабатывает столкновения с врагами
   - Управляет жизнями персонажа

5. **Enemy** - базовый класс для врагов:
   - Наследуется от Actor
   - Имеет различные подклассы с разным поведением
   - Может стрелять и умирать от снарядов героя

### Процесс гравитации

Гравитация реализована в классе `Character` через метод `gravitate()`:
```python
def gravitate(self):
    self.y_speed += self.heavy
```

Где `self.heavy` - константа гравитации, определенная в `constants.py`. Гравитация применяется в методе `update()`, который вызывается каждый кадр.

### Процесс движения стрелы

Стрельба реализована в классе `Actor` через метод `fire()`:
```python
def fire(self, img, is_Enemy):
    rect = img.get_rect()
    rect.y = self.rect.centery
    if self.direction > 0:
        rect.left = self.rect.right
        area = pygame.Rect(rect.left, rect.top, FIRE_DISTANCE, win_height-rect.top)
        f_speed = FIRE_SPEED
    else:
        rect.right = self.rect.left
        area = pygame.Rect(rect.right - FIRE_DISTANCE, rect.top, FIRE_DISTANCE, win_height-rect.top)
        f_speed = -1 * FIRE_SPEED
```

Стрела создается как объект класса `Fire` и добавляется в соответствующую группу спрайтов.

### Процесс коллизии объектов

Коллизии обрабатываются в нескольких местах:

1. В методе `update()` класса `Character`:
   - Проверка столкновений с платформами
   - Обработка приземления на платформы
   - Проверка выхода за границы уровня

2. В методе `update()` класса `Hero`:
   - Проверка столкновений с врагами
   - Обработка получения урона

3. В методе `update()` класса `Enemy`:
   - Проверка столкновений со снарядами героя
   - Обработка уничтожения врага

## Требуемые модификации

### 1. Закрытие программы по "крестику"

Текущая реализация уже включает обработку закрытия по крестику в `arcada_main.py`:
```python
if event.type == pygame.QUIT:
    game.stop()
```

### 2. Видоизменение меню подсказок

Меню подсказок реализовано в `game_help.py`. Необходимо модифицировать его для улучшения пользовательского интерфейса.

### 3. Добавление жизней главному игроку

Система жизней уже реализована в классе `Hero`:
```python
def die(self):
    game.minus_lives()
    super().die()
```

### 4. Создание нового уровня

Необходимо создать новый уровень в `level_config.py`, заменив существующий второй уровень. Новый уровень должен включать:
- Уникальный фон
- Новое расположение платформ
- Новые типы врагов
- Новое расположение цели

## Выводы

В ходе работы мы изучили:
1. Основы работы с pygame и обработкой событий
2. Принципы объектно-ориентированного программирования при создании игровых объектов
3. Реализацию физики и коллизий в 2D-игре
4. Создание и управление уровнями

Полученные знания могут быть применены при разработке:
- 2D-игр на Python
- Интерактивных приложений с графическим интерфейсом
- Образовательных программ с игровыми элементами
- Симуляторов физических процессов 